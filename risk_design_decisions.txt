Given that the game needed to be made GUI-based, one of the big design decisions was how to represent and interact with the map.
The two options we were considering were to draw the map in a GUI component with polygons or add a full map as a background image
and add regular buttons on top of each country. With drawing the map from scratch, you would be able to click anywhere on a country
to select it, but handling those mouse clicks would be inefficient because you would have to loop through each polygon that represents
a country to check if the click was inside the polygon. Therefore, we chose the second option of having a background image with buttons
on top, sacrificing the ideal user experience to be able to handle mouse clicks much more efficiently. The MapComponent class is responsible
for this by drawing the map image in the paintComponent method and setting the layout to absolute to allow buttons to be placed on top
of the image at a specific point in the window.

Another decision was how to output information to the user, since the console that was being used in milestone 1 was not an option.
One option was to essentially move the console into a JTextArea in the View class, and the other option was to display a dialog box
for each message the user needed to see. Since dialog boxes interrupt the game to ensure the user sees the message, and
an update to a JTextArea may go unnoticed, we decided to use dialog boxes. Dialog boxes with inputs were also used to get the number
of players and number of dice, so the Parser, Command, and CommandWord classes were no longer needed. This meant that the play and
processCommand methods in Model were not needed and the attack and pass methods could be made public for the controller to call.

As referenced above with the controller, the game needed to follow the MVC pattern, so we added a View and Controller class to adhere
to the pattern. Whenever a button on the game is clicked the actionPerformed method in Controller is invoked, and it determines which
Model method to call. Inside each Model method that changes the state of the game, there is a call to a method in View that updates the
View based on what aspect of the Model was changed. This presented another design decision of how to connect buttons to Country objects
and Country objects to buttons because a certain Country object should be accessed when its button is pressed and a certain button
should be accessed when its Country object changes state. This could be easily solved by having a hashmap of buttons and countries
and a hashmap of countries and buttons, but this seems to be overlapping. Instead there should be one hashmap of countries and buttons
and another solution to connect buttons and countries. One solution is to make a specific controller for each button that stores the
Country object that it represents, and the other solution is to make a new class that extends JButton that stores the Country object
it represents. To keep the MVC pattern as simple as possible, we decided to choose the second option, and this new class that extends
JButton is the CountryButton class.
